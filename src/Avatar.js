/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import React, { useRef, useEffect, useState, useMemo } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader"
import * as THREE from "three"
import lerp from "lerp"
import { getMouseDegrees } from './utils'
import { useLoader, useFrame } from "@react-three/fiber";

function moveJoint(mouse, joint, degreeLimit = 40) {
  let degrees = getMouseDegrees(mouse.current.x, mouse.current.y, degreeLimit)
  joint.rotation.xD = lerp(joint.rotation.xD || 0, degrees.y, 0.1)
  joint.rotation.yD = lerp(joint.rotation.yD || 0, degrees.x, 0.1)
  joint.rotation.x = THREE.MathUtils.degToRad(joint.rotation.xD)
  joint.rotation.y = THREE.MathUtils.degToRad(joint.rotation.yD)
}

export default function Avatar({mouse, ...props }) {
  const group = useRef()
  const actions = useRef ()
  const { nodes, materials, animations } = useGLTF('/Avatar.glb')
 

const gltf = useLoader (GLTFLoader, "/Avatar.glb")
const [bones, skeleton, neck, waist] = useMemo(() => {
  // By putting bones into the view Threejs removes it automatically from the
  // cached scene. Next time the component runs these two objects will be gone.
  // Since the gltf object is a permenently cached object, we can extend it here
  // and extend it with all the data we may need.
  if (!gltf.bones) gltf.bones = gltf.scene.children[0].children[0]
  if (!gltf.skeleton) gltf.skeleton = gltf.scene.children[0].children[1].skeleton
  if (!gltf.neck) {
    gltf.bones.traverse(o => {
      if (o.isBone && o.name === "head") gltf.neck = o
      if (o.isBone && o.name === "spine_03") gltf.waist = o
    })
  }
  return [gltf.bones, gltf.skeleton, gltf.neck, gltf.waist]
}, [gltf])

const [mixer] = useState(() => new THREE.AnimationMixer())
  useEffect(() => {
    actions.current = {
      Idle: mixer.clipAction(gltf.animations[0], group.current),
    }
    actions.current.Idle.play()
    return () => gltf.animations.forEach(clip => mixer.uncacheClip(clip))
  }, [mixer, gltf])

  useFrame((state, delta) => {
    mixer.update(delta)
    moveJoint(mouse, neck)
    moveJoint(mouse, waist)
  })


  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
       <group name="Merged_Idle_Test" scale={0.01}>
           <primitive object={bones} />
         <skinnedMesh name="Retopo_Hoodie_2D_001_Solidified" geometry={nodes.Retopo_Hoodie_2D_001_Solidified.geometry} material={materials.SimplifiedMaterial} skeleton={skeleton} morphTargetDictionary={nodes.Retopo_Hoodie_2D_001_Solidified.morphTargetDictionary} morphTargetInfluences={nodes.Retopo_Hoodie_2D_001_Solidified.morphTargetInfluences} />
       </group>
      </group>
    </group>
  )
}

